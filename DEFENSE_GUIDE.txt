================================================================================
FINANCIAL CHATBOT - DEFENSE GUIDE
================================================================================
Last Updated: December 8, 2025
Author: Benson Ricohermoso

This guide explains how the entire system works in simple terms for your defense.

================================================================================
1. SYSTEM OVERVIEW
================================================================================

What does this system do?
- It's a web-based financial chatbot that helps users track expenses and savings
- Users can type natural language like "spent 150 on food" and the system records it
- It shows analytics with charts (pie charts, bar graphs, line charts)
- Everything is stored in a database so data persists

Technology Stack:
- Backend: Flask (Python web framework)
- Database: SQLite (local file-based database)
- Frontend: HTML/CSS/JavaScript with Chart.js
- Deployment: Vercel (cloud hosting platform)

================================================================================
2. HOW FLASK WORKS
================================================================================

What is Flask?
- Flask is a lightweight Python web framework
- It lets you create web applications with Python code
- It handles HTTP requests (when users visit pages or submit forms)

How we use Flask in this project:

1. Import Flask and create an app instance (app.py, line 1-9):
   ```
   from flask import Flask, render_template, request, jsonify
   app = Flask(__name__)
   ```

2. Define routes (URLs that users can visit):
   
   @app.route('/') - Homepage route
   - When user visits http://yoursite.com/
   - Function: index()
   - Returns: index.html template (chat interface)
   
   @app.route('/chat', methods=['POST']) - Chat endpoint
   - When user sends a message
   - Function: chat()
   - Receives: JSON with user message
   - Returns: JSON with chatbot response
   
   @app.route('/analytics') - Analytics page
   - When user clicks "Analytics" link
   - Function: analytics()
   - Returns: analytics.html template
   
   @app.route('/api/summary/<period>') - Get financial summary
   - When analytics page loads data
   - Function: get_summary(period)
   - Returns: JSON with totals and chart data

3. Run the Flask server (app.py, line 131):
   ```
   app.run(debug=True, port=5000)
   ```
   - Starts web server on http://127.0.0.1:5000

================================================================================
3. HOW PYTHON CONNECTS TO DATABASE (SQLite)
================================================================================

What is SQLite?
- It's a file-based database (stores data in a .db file)
- No separate server needed (unlike MySQL)
- Perfect for small applications

How we connect to SQLite:

1. Import sqlite3 module (database/db_manager.py, line 1):
   ```
   import sqlite3
   ```

2. Create connection (database/db_manager.py, line 12-14):
   ```
   def get_connection(self):
       conn = sqlite3.connect(self.db_path)  # Opens financial_chatbot.db
       conn.row_factory = sqlite3.Row  # Makes results accessible like dictionaries
       return conn
   ```

3. Execute SQL queries (database/db_manager.py, line 63-69):
   ```
   def execute_query(self, query, params=()):
       conn = self.get_connection()
       cursor = conn.cursor()
       cursor.execute(query, params)  # Run SQL command
       conn.commit()  # Save changes
       conn.close()  # Close connection
   ```

4. Fetch data (database/db_manager.py, line 71-77):
   ```
   def fetch_all(self, query, params=()):
       conn = self.get_connection()
       cursor = conn.cursor()
       cursor.execute(query, params)
       results = cursor.fetchall()  # Get all rows
       conn.close()
       return results
   ```

Database Tables Created:

1. categories table:
   - category_id (unique ID)
   - category_name (Food, Transport, etc.)
   - category_type (expense or savings)
   - keywords (words to match: lunch, dinner, food, etc.)

2. transactions table:
   - transaction_id (unique ID)
   - transaction_type (expense or savings)
   - amount (how much money)
   - category_id (links to categories table)
   - description (user's original message)
   - date (when transaction happened)

3. chatbot_responses table:
   - response_id (unique ID)
   - keywords (trigger words)
   - response_text (what bot says)
   - response_type (greeting, help, advice)

================================================================================
4. HOW THE SYSTEM PROCESSES USER MESSAGES
================================================================================

Step-by-Step Flow (app.py, chat() function):

1. User types message in chat box
   Example: "spent 150 on food"

2. Frontend JavaScript sends POST request to /chat endpoint
   Data sent: {"message": "spent 150 on food"}

3. Flask receives the message (app.py, line 29):
   ```
   user_message = request.json.get('message', '')
   ```

4. Message Parser analyzes it (chatbot/message_parser.py):
   
   Function: parse_message(message)
   
   Step A: Check intent (what user wants to do)
   - is_greeting() â†’ User saying hi?
   - is_help_request() â†’ User asking for help?
   - is_delete_request() â†’ User wants to delete?
   - is_update_request() â†’ User wants to update?
   - is_query() â†’ User asking for summary?
   
   Step B: Extract information using regex (chatbot/patterns.py)
   - extract_amount() â†’ Finds "150" from message
   - extract_action() â†’ Determines "expense" (because word "spent")
   - match_category() â†’ Finds "food" matches Food category
   - extract_date() â†’ Gets date if mentioned (like "december 1")
   
   Returns parsed data:
   {
       'intent': 'record_transaction',
       'amount': 150,
       'action': 'expense',
       'category_id': 1,
       'category_name': 'Food',
       'description': 'spent 150 on food',
       'date': datetime.now()
   }

5. Flask decides what to do based on intent (app.py, line 40-82):

   If intent = 'record_transaction':
   - Call transaction_model.create_transaction()
   - This runs SQL INSERT to add record to database
   - Generate response: "âœ“ Recorded: 150 pesos spent on Food"
   
   If intent = 'query':
   - Call report_gen.generate_summary(period)
   - This runs SQL SELECT to get transactions
   - Returns summary text and data
   
   If intent = 'delete':
   - Get last transaction from database
   - Call transaction_model.delete_transaction()
   - This runs SQL DELETE command
   - Response: "âœ“ Deleted: 150 pesos on Food"
   
   If intent = 'update':
   - Find transaction matching category + date
   - Call transaction_model.update_transaction()
   - This runs SQL UPDATE command
   - Response: "âœ“ Updated: set Food on 2025-12-01 to 250 pesos"

6. Send response back to user (app.py, line 86-90):
   ```
   return jsonify({
       'response': response_text,
       'intent': intent,
       'chart': chart_data
   })
   ```

7. Frontend JavaScript displays response in chat

================================================================================
5. KEY FUNCTIONS AND WHAT THEY DO
================================================================================

FILE: models/transaction.py
-----------------------------

create_transaction(transaction_type, amount, category_id, description, date)
  Purpose: Add new transaction to database
  SQL: INSERT INTO transactions VALUES (...)
  Returns: transaction_id (unique ID of new record)

get_transactions(start_date, end_date, limit)
  Purpose: Retrieve transactions from database
  SQL: SELECT * FROM transactions WHERE date BETWEEN ...
  Returns: List of transaction records

update_transaction(transaction_id, **kwargs)
  Purpose: Modify existing transaction
  SQL: UPDATE transactions SET amount = ? WHERE transaction_id = ?
  Returns: True if successful

delete_transaction(transaction_id)
  Purpose: Remove transaction from database
  SQL: DELETE FROM transactions WHERE transaction_id = ?
  Returns: True if successful

FILE: chatbot/message_parser.py
--------------------------------

parse_message(message)
  Purpose: Analyze user message and extract meaning
  Uses: Regex patterns, keyword matching
  Returns: Dictionary with intent, amount, category, date

match_category(message)
  Purpose: Find which category user is talking about
  How: Checks message words against category keywords
  Returns: category_id and category_name

FILE: chatbot/patterns.py
-------------------------

extract_amount(message)
  Purpose: Find numbers in message
  Regex: r'(\d+(?:\.\d{1,2})?)\s*(?:pesos?|php|â‚±)?'
  Example: "spent 150 pesos" â†’ returns 150.0

extract_action(message)
  Purpose: Determine if expense or savings
  How: Checks for keywords (spent, paid â†’ expense; saved, earned â†’ savings)
  Returns: "expense" or "savings"

extract_date(message)
  Purpose: Find dates like "december 1"
  How: Regex pattern matching month names
  Returns: datetime object

is_update_request(message)
  Purpose: Check if user wants to update
  How: Looks for words: update, change, edit, modify
  Returns: True or False

FILE: analytics/report_generator.py
------------------------------------

generate_summary(period)
  Purpose: Create financial summary for time period
  Steps:
    1. Calculate date range (today, week, month, year)
    2. Query all transactions in that range
    3. Sum up expenses and savings
    4. Group by category for breakdown
    5. Format as readable text
  Returns: (summary_text, data_dictionary)

get_recent_transactions(limit)
  Purpose: Get last N transactions
  SQL: SELECT * FROM transactions ORDER BY date DESC LIMIT ?
  Returns: Formatted list of recent transactions

FILE: analytics/chart_generator.py
-----------------------------------

generate_category_pie_chart(category_data)
  Purpose: Create data for pie chart
  Input: {"Food": 500, "Transport": 200}
  Output: {"type": "pie", "labels": ["Food", "Transport"], "data": [500, 200]}
  Note: Frontend Chart.js renders this into actual chart

generate_spending_trend(transactions)
  Purpose: Create data for line graph
  Groups transactions by date
  Output: {"type": "line", "labels": ["2025-12-01", "2025-12-02"], "data": [150, 200]}

generate_savings_vs_expense_chart(data)
  Purpose: Create data for bar chart
  Output: {"type": "bar", "labels": ["Savings", "Expenses", "Net"], "data": [1000, 500, 500]}

================================================================================
6. HOW DATABASE INITIALIZATION WORKS
================================================================================

When app starts (database/db_manager.py, __init__ method):

1. Check if database file exists
2. If not, create it using init_database()

init_database() does (line 16-60):

1. Create tables if they don't exist (SQL CREATE TABLE IF NOT EXISTS)

2. Check if categories table is empty

3. If empty, insert default categories from config.py:
   - Food (keywords: lunch, dinner, breakfast, meal, food)
   - Transportation (keywords: taxi, jeep, bus, fare, gas)
   - Bills (keywords: electricity, water, internet, rent)
   - Shopping (keywords: shopping, clothes, shoes, mall)
   - Health (keywords: medicine, doctor, hospital)
   - Education (keywords: school, books, tuition)
   - Salary (keywords: salary, wage, paycheck)
   - Savings (keywords: save, saved, saving)
   - etc.

4. Insert default chatbot responses:
   - Greeting response
   - Help response
   - Advice response

This ensures database is ready to use when app starts.

================================================================================
7. HOW VERCEL DEPLOYMENT WORKS
================================================================================

What is Vercel?
- Cloud platform for hosting web applications
- Serverless (no need to manage servers)
- Automatically builds and deploys from GitHub

Files needed for Vercel:

1. vercel.json (tells Vercel how to run the app):
   ```
   {
     "version": 2,
     "builds": [{"src": "app.py", "use": "@vercel/python"}],
     "routes": [{"src": "/(.*)", "dest": "app.py"}]
   }
   ```
   Explanation:
   - "builds" â†’ Use Python builder for app.py
   - "routes" â†’ Send all requests to app.py

2. runtime.txt (specifies Python version):
   ```
   python-3.9
   ```
   Tells Vercel to use Python 3.9

3. requirements.txt (lists dependencies):
   ```
   Flask>=2.3.0,<4.0.0
   python-dateutil>=2.8.0
   ```
   Vercel installs these packages before running app

4. .vercelignore (files to exclude):
   ```
   venv/
   __pycache__/
   *.db
   ```
   Don't upload virtual environment or cache files

Deployment Process:

1. Push code to GitHub
2. Connect Vercel to your GitHub repository
3. Vercel detects vercel.json
4. Vercel runs: pip install -r requirements.txt
5. Vercel builds the app
6. App is live at: https://your-project.vercel.app

Important Note:
- On Vercel, SQLite uses /tmp directory (temporary storage)
- Data is lost when app restarts (ephemeral storage)
- For production, need persistent database like PostgreSQL

How we handle this (config.py, line 5):
```
DATABASE_PATH = os.environ.get('DATABASE_PATH', 
    '/tmp/financial_chatbot.db' if os.environ.get('VERCEL') else 'financial_chatbot.db')
```
- If running on Vercel â†’ use /tmp/
- If running locally â†’ use current directory

================================================================================
8. HOW CHARTS WORK (Frontend)
================================================================================

Original Approach (removed):
- Used matplotlib (Python library) to generate chart images
- Problem: matplotlib requires numpy (heavy dependency, 100+ MB)
- Caused Vercel deployment failures

Current Approach:
- Backend sends JSON data only
- Frontend uses Chart.js (JavaScript library) to render charts

Example Flow:

1. User visits /analytics page

2. JavaScript loads (analytics.html, line 215):
   ```
   async function loadAnalytics(period) {
       const response = await fetch(`/api/summary/${period}`);
       const data = await response.json();
       displayAnalytics(data);
   }
   ```

3. Flask endpoint returns JSON (app.py, line 96-120):
   ```
   {
       "charts": {
           "pie": {"type": "pie", "labels": ["Food", "Transport"], "data": [500, 200]},
           "trend": {"type": "line", "labels": ["Dec 1", "Dec 2"], "data": [150, 200]},
           "comparison": {"type": "bar", "labels": ["Savings", "Expenses"], "data": [1000, 500]}
       }
   }
   ```

4. JavaScript creates canvas elements (analytics.html, line 245-255):
   ```
   <canvas id="pieChart"></canvas>
   ```

5. Chart.js renders the chart (analytics.html, line 295-315):
   ```
   function renderPieChart(canvasId, chartData) {
       const ctx = document.getElementById(canvasId).getContext('2d');
       new Chart(ctx, {
           type: 'pie',
           data: {
               labels: chartData.labels,
               datasets: [{data: chartData.data}]
           }
       });
   }
   ```

Benefits:
- Lightweight (no heavy Python dependencies)
- Works on Vercel (no build issues)
- Interactive charts (hover, click, zoom)
- Responsive on mobile

================================================================================
9. FILE INTERACTIONS (HOW EVERYTHING CONNECTS)
================================================================================

Request Flow Example: User sends "spent 150 on food"

1. templates/index.html
   - User types in input box
   - JavaScript: sendMessage() function triggered
   - Sends POST to /chat endpoint

2. app.py (Flask backend)
   - @app.route('/chat', methods=['POST'])
   - Receives message
   - Calls: parser.parse_message(user_message)

3. chatbot/message_parser.py
   - parse_message() function
   - Imports patterns from: chatbot/patterns.py
   - Uses: extract_amount(), extract_action(), match_category()
   - Queries: models/category.py â†’ get_categories_dict()

4. models/category.py
   - get_categories_dict() function
   - Calls: database/db_manager.py â†’ fetch_all()

5. database/db_manager.py
   - fetch_all() function
   - Executes: SELECT * FROM categories
   - Returns category data to category.py

6. chatbot/message_parser.py (continues)
   - Matches "food" keyword to Food category
   - Returns parsed data to app.py

7. app.py (continues)
   - Sees intent = 'record_transaction'
   - Calls: transaction_model.create_transaction()

8. models/transaction.py
   - create_transaction() function
   - Calls: database/db_manager.py â†’ execute_query()

9. database/db_manager.py
   - execute_query() function
   - Executes: INSERT INTO transactions VALUES (...)
   - Saves to financial_chatbot.db file
   - Returns transaction_id

10. app.py (continues)
    - Calls: response_gen.generate_response()

11. chatbot/response_generator.py
    - transaction_recorded_response() function
    - Formats: "âœ“ Recorded: 150 pesos spent on Food"
    - Returns to app.py

12. app.py (continues)
    - Returns JSON: {"response": "âœ“ Recorded...", "intent": "record_transaction"}

13. templates/index.html
    - JavaScript receives response
    - addMessage() function displays it in chat

Summary of File Dependencies:
```
app.py
â”œâ”€â”€ chatbot/message_parser.py
â”‚   â”œâ”€â”€ chatbot/patterns.py
â”‚   â””â”€â”€ models/category.py
â”‚       â””â”€â”€ database/db_manager.py
â”œâ”€â”€ models/transaction.py
â”‚   â””â”€â”€ database/db_manager.py
â”œâ”€â”€ chatbot/response_generator.py
â”‚   â””â”€â”€ database/db_manager.py
â”œâ”€â”€ analytics/report_generator.py
â”‚   â”œâ”€â”€ models/transaction.py
â”‚   â””â”€â”€ database/db_manager.py
â””â”€â”€ analytics/chart_generator.py
```

================================================================================
10. IMPORTANT CONCEPTS TO EXPLAIN
================================================================================

1. MVC Pattern (Model-View-Controller):
   - Model (models/): Handles data and database
   - View (templates/): What user sees (HTML)
   - Controller (app.py + chatbot/): Business logic

2. REST API:
   - POST /chat â†’ Create/process message
   - GET /api/summary/today â†’ Read data
   - Routes use HTTP methods (GET, POST)

3. JSON (JavaScript Object Notation):
   - Format for data exchange
   - Example: {"message": "hello"}
   - Easy for JavaScript and Python to understand

4. Regular Expressions (Regex):
   - Pattern matching for text
   - Example: r'\d+' matches numbers
   - Used to extract amounts, dates from messages

5. SQL (Structured Query Language):
   - INSERT: Add new record
   - SELECT: Read records
   - UPDATE: Modify record
   - DELETE: Remove record

6. Frontend vs Backend:
   - Frontend: What user sees (HTML/CSS/JS)
   - Backend: Logic and database (Python/Flask)
   - They communicate via HTTP requests

7. Serverless:
   - No dedicated server to maintain
   - Code runs only when needed
   - Vercel handles infrastructure

================================================================================
11. COMMON DEFENSE QUESTIONS & ANSWERS
================================================================================

Q: Why did you choose Flask over Django?
A: Flask is lightweight and simple for small projects. Django is overkill for a 
   chatbot with basic CRUD operations. Flask gives more control and is easier 
   to deploy on Vercel.

Q: Why SQLite instead of MySQL/PostgreSQL?
A: For local development and small-scale apps, SQLite is perfect. No setup 
   needed, no separate server. For production scaling, we'd migrate to 
   PostgreSQL (as noted in README).

Q: How does the chatbot understand natural language?
A: It uses pattern matching and regex, not AI/ML. We check for keywords 
   (spent, saved) and extract numbers using regex patterns. Categories are 
   matched by comparing message words to predefined keyword lists.

Q: What if user types something the bot doesn't understand?
A: The parser checks all intent patterns (greeting, help, delete, update, query, 
   record). If none match, intent becomes 'unknown' and bot responds: 
   "I'm not sure what you mean. Try saying 'spent 50 on lunch'"

Q: How do you prevent SQL injection?
A: We use parameterized queries. Instead of:
   execute(f"INSERT INTO transactions VALUES ('{amount}')")
   We use:
   execute("INSERT INTO transactions VALUES (?)", (amount,))
   The ? placeholder is safely escaped by sqlite3 module.

Q: Why remove matplotlib if it makes nice charts?
A: Matplotlib requires numpy (100+ MB). Vercel has package size limits and 
   build timeouts. Chart.js is better: lighter weight, interactive, responsive,
   and works perfectly on mobile devices.

Q: How does the update function work?
A: User says "update 250 in food on december 1"
   1. Parser extracts: amount=250, category=food, date=december 1
   2. System queries database for transactions matching that category and date
   3. Finds the most recent matching transaction
   4. Runs SQL UPDATE to change the amount to 250
   5. Returns confirmation message

Q: What happens when database resets on Vercel?
A: Since Vercel uses /tmp (temporary storage), database resets after ~15 
   minutes of inactivity or on redeployment. For production, we'd use Vercel 
   Postgres or Supabase to persist data permanently.

Q: How is this different from a regular calculator app?
A: This uses natural language (conversational) instead of buttons and forms.
   Users can type "spent 50 on lunch" instead of filling out expense form.
   Plus it has analytics, trends, and intelligent category matching.

Q: Can you add more categories?
A: Yes, edit config.py DEFAULT_CATEGORIES list. Add:
   ('Category Name', 'expense', 'keyword1,keyword2,keyword3')
   Restart app, and it will insert the new category into database.

Q: Is the data secure?
A: Currently it's local only (SQLite file). For production, we'd add:
   - User authentication (login system)
   - Encrypted database connection
   - HTTPS for all requests
   - Environment variables for sensitive data

================================================================================
12. TESTING CHECKLIST
================================================================================

Things to test during demo:

1. Record expense: "spent 100 on food"
   âœ“ Should show: "âœ“ Recorded: 100 pesos spent on Food"

2. Record savings: "saved 500"
   âœ“ Should show: "âœ“ Recorded: 500 pesos saved in Savings"

3. Query today: "show today summary"
   âœ“ Should display summary with totals

4. Delete: "delete last transaction"
   âœ“ Should remove most recent transaction

5. Update: "update 250 in food on december 8"
   âœ“ Should find and update matching transaction

6. Navigate to Analytics page
   âœ“ Click Analytics link
   âœ“ Charts should load
   âœ“ Try different periods (Today, Week, Month, Year)

7. Mobile test
   âœ“ Resize browser window
   âœ“ Check responsive layout
   âœ“ Verify touch-friendly buttons

8. Help: "help"
   âœ“ Should show list of commands

================================================================================
13. FINAL TIPS FOR DEFENSE
================================================================================

1. Be confident about what you know:
   - You understand the user flow
   - You know what each function does
   - You can trace the code execution

2. If asked about something you're unsure:
   - "Let me trace through the code to show you exactly how it works"
   - Open the file and explain line by line
   - This guide has all the details you need

3. Emphasize the good design decisions:
   - Modular structure (separation of concerns)
   - Reusable functions (DRY principle)
   - Responsive design (mobile-friendly)
   - Scalable architecture (easy to add features)

4. Acknowledge limitations honestly:
   - "For a production system, we'd use PostgreSQL instead of SQLite"
   - "We'd add user authentication for multi-user support"
   - "We'd implement proper error handling and logging"

5. Show you understand the bigger picture:
   - MVC architecture
   - Client-server communication
   - Database normalization (foreign keys)
   - API design (RESTful endpoints)

================================================================================
GOOD LUCK WITH YOUR DEFENSE!
================================================================================

Remember: You don't need to memorize everything. Use this guide during your 
defense. The key is understanding the flow and being able to explain each 
part when asked.

Focus on:
1. How user input flows through the system
2. How database operations work
3. How Flask routes requests
4. How different files work together

You've got this! ðŸš€
